

# Tech thoughts.

What you do to become better at your job in the next two weeks can make your career less
successful in the next two years. Delivering a project a couple days faster by working at night, or on the weekend,
can sometimes be important. Particularly if it's a product launch and something you're responsible for. However,
usually this type of last-minute work (but not always) focuses on specific implementation details, and doing things you know how to do,
but faster. 

On the other hand, what you do to be better at your job in the next two months often has to do with learning a specific technology or API.
Learning APIs is definitely important, it's how we build out solutions to specific problems. But most APIs eventually are deprecated in some capacity.
Being a scikit-learn or Pandas API wizz is great, and it's worth doing. But it won't differentiate you in ten years from now, when
you're competing with recent grads who just trained on the hot new library. So you know how to write performant pandas, that's cool.
But what you really know is how to memorize tricks. 

Focusing on two weeks, and two months, is important, and you should do it. I do it. But you should also make time
to focus on what will make you better at your job two years from now. This typically requires investing in foundations that don't
appear to offer an obvious, immediate, return.

For me, some recent examples are things like more esoteric proofs in mathematical statistics. I recently was working through natural parameters for exponential family distributions,
and inequalities. This builds statistical maturity, which is an investment in your ability to rapidly learn and reason about new types of models. 
Obviously I have no need to use inequalities in my job in the forseeable future. 

I've also spent time (not a tremendous amount) learning Clojure (which is what this website is written in, although there isn't much!). Disciplining myself
to write higher quality functional code improves my ability to read, review, and reason about software in the long-run. 

The scary part of this is that no one cares if you learn fundamentals, and no one will push you to do it, unless you are fortunate enough to have
an unusually thoughtful manager or mentor. On the margin, if you are a very hard worker, it's tempting to spend your weekend improving your
immediate project you're responsible for shipping. You get a nice, tight, reward feedback loop. On the other hand, risking missing a deadline to instead
work through proofs can feel awkward. But in many cases it's worth it, and you should do it anyway.

Don't rely on your manager to serve you up the perfect project that aligns your career and intellectual interests, and lets you optimize yourself
for two weeks, two months, and two years. That project probably doesn't exist. Instead take full personal responsibility for your skill set
in two years from now. That's on you.


